else
{
print("")
}
}
}
for(j in 1:nrow(dfMalCases))
{
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
tempMat = cbind(tempMat, c(1:60))
positionToEstimate = which(is.na(tempMat[, 1]))
print(positionToEstimate)
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
}
else
{
if (nrow(M) >= 4 && sum(M[, 1] != 0))
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(10, nrow(M)), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, j] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
print("")
}
}
}
for(j in 1:nrow(dfMalCases))
{
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
tempMat = cbind(tempMat, c(1:60))
positionToEstimate = which(is.na(tempMat[, 1]))
print(positionToEstimate)
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
}
else
{
if (nrow(M) >= 4 && sum(M[, 1] != 0))
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(5, nrow(M)), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, j] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
print("")
}
}
}
for(j in 1:nrow(dfMalCases))
{
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
tempMat = cbind(tempMat, c(1:60))
positionToEstimate = which(is.na(tempMat[, 1]))
print(positionToEstimate)
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
tempMat[, 1] = rep(0, length.out = c)
}
else
{
if (nrow(M) >= 4 && sum(M[, 1] != 0))
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(5, nrow(M)), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
}
for(j in 1:nrow(dfMalCases))
{
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
tempMat = cbind(tempMat, c(1:60))
positionToEstimate = which(is.na(tempMat[, 1]))
print(positionToEstimate)
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
#tempMat[, 1] = rep(0, length.out = c)
}
else
{
if (nrow(M) >= 4 && sum(M[, 1] != 0))
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(5, nrow(M)), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
}
for(j in 1:nrow(dfMalCases))
{
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
tempMat = cbind(tempMat, c(1:60))
positionToEstimate = which(is.na(tempMat[, 1]))
print(positionToEstimate)
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
#tempMat[, 1] = rep(0, length.out = c)
}
else
{
if (nrow(M) >= 5 && sum(M[, 1] != 0))
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(5, nrow(M)), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
}
for(j in 1:nrow(dfMalCases))
{
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
tempMat = cbind(tempMat, c(1:60))
positionToEstimate = which(is.na(tempMat[, 1]))
print(positionToEstimate)
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
#tempMat[, 1] = rep(0, length.out = c)
}
else
{
if (nrow(M) >= 5 && sum(M[, 1] != 0))
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(4, nrow(M)), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
}
for(j in 1:nrow(dfMalCases))
{
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
tempMat = cbind(tempMat, c(1:60))
positionToEstimate = which(is.na(tempMat[, 1]))
print(positionToEstimate)
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
#tempMat[, 1] = rep(0, length.out = c)
}
else
{
if (nrow(M) >= 5 && sum(M[, 1] != 0))
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(4, length(unique(x))), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
}
for(j in 1:nrow(dfMalCases))
{
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
tempMat = cbind(tempMat, c(1:60))
positionToEstimate = which(is.na(tempMat[, 1]))
print(positionToEstimate)
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
#tempMat[, 1] = rep(0, length.out = c)
}
else
{
if (nrow(M) >= 5 && sum(M[, 1] != 0))
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(4, length(unique(M[, 1]))), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
}
for(j in 1:nrow(dfMalCases))
{
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
tempMat = cbind(tempMat, c(1:60))
positionToEstimate = which(is.na(tempMat[, 1]))
print(positionToEstimate)
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
#tempMat[, 1] = rep(0, length.out = c)
}
else
{
if (nrow(M) >= 5 && sum(M[, 1] != 0) && length(positionToEstimate)>0)
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(4, length(unique(M[, 1]))), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
}
filledDataFrame = data.frame()
for(j in 1:nrow(dfMalCases))
{
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
tempMat = cbind(tempMat, c(1:60))
positionToEstimate = which(is.na(tempMat[, 1]))
print(positionToEstimate)
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
tempMat[, 1] = rep(0, length.out = c)
}
else
{
if (nrow(M) >= 5 && sum(M[, 1] != 0) && length(positionToEstimate)>0)
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(4, length(unique(M[, 1]))), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
filledDataFrame = rbind(filledDataFrame, t(tempMat[, 1]))
}
filledDataFrame
for(j in 1:nrow(dfMalCases))
{
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
tempMat = cbind(tempMat, c(1:60))
positionToEstimate = which(is.na(tempMat[, 1]))
print(positionToEstimate)
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
tempMat[, 1] = rep(0, length.out = c)
}
else
{
if (nrow(M) >= 5 && sum(M[, 1] != 0) && length(positionToEstimate)>0)
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(4, length(unique(M[, 1]))), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
filledDataFrame = rbind(filledDataFrame, t(tempMat[, 1]))
}
source("F:/Jembi/Gondar/DataInterpolation.R", echo=TRUE)
head(filledDataFrame)
print(filledDataFrame[1, ])
plot(filledDataFrame[1, ])
max(filledDataFrame[1, ])
plot(t(filledDataFrame[1, ]))
source("F:/Jembi/Gondar/DataInterpolation.R", echo=TRUE)
head(filledDataFrame)
head(dfMalCases)
colnames(filledDataFrame) = colnames(dfMalCases)
head(dfMalCases)
head(filledDataFrame)
# Pacman loads in the libraries, and if they arent installed then installs them
pacman::p_load(readxl, dplyr, stringr, splines, writexl)
for(j in 1:nrow(dfMalCases))
{
# for each row, make a temporary matrix, removing the organisation unit name
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
# Add the times for each entry, from month 1 to month 60
tempMat = cbind(tempMat, c(1:60))
# Finding position of NA values
positionToEstimate = which(is.na(tempMat[, 1]))
# print(positionToEstimate)
#
M <- tempMat
colnames(M) = c("y", "x")
if (all(is.na(M[, 1])))
{
noDataAreas = c(noDataAreas, j)
tempMat[, 1] = rep(0, length.out = c-1)
}
else
{
if (nrow(M) >= 5 && sum(M[, 1] != 0) && length(positionToEstimate)>0)
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(4, length(unique(M[, 1]))), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
filledDataFrame = rbind(filledDataFrame, c(dfMalCases$organisationunitname[j], t(tempMat[, 1])))
}
for(j in 1:nrow(dfMalCases))
{
# for each row, make a temporary matrix, removing the organisation unit name
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
# Add the times for each entry, from month 1 to month 60
tempMat = cbind(tempMat, c(1:60))
# Finding position of NA values
positionToEstimate = which(is.na(tempMat[, 1]))
# print(positionToEstimate)
#
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
if (all(is.na(tempMat[, 1])))
{
noDataAreas = c(noDataAreas, j)
tempMat[, 1] = rep(0, length.out = c-1)
}
else
{
if (nrow(M) >= 5 && sum(M[, 1] != 0) && length(positionToEstimate)>0)
{
plot(M[, 2], M[, 1])
fit = lm(y ~ bs(x, df = min(4, length(unique(M[, 1]))), Boundary.knots = c(1, 60)), data = M)
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
predNA = predict(fit, data.frame(x = positionToEstimate))
print(pmin(pmax(predNA, 0), max(M[, 1])))
print(head(tempMat))
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
filledDataFrame = rbind(filledDataFrame, c(dfMalCases$organisationunitname[j], t(tempMat[, 1])))
}
colnames(filledDataFrame) = colnames(dfMalCases)
write_xlsx(filledDataFrame, "malaria_cases.xlsx")
source("F:/Jembi/Gondar/DataInterpolation.R", echo=TRUE)
for(j in 1:nrow(dfMalCases))
{
# for each row, make a temporary matrix, removing the organisation unit name
tempMat = as.data.frame(t(dfMalCases[j, 2:c]))
# Add the times for each entry, from month 1 to month 60
tempMat = cbind(tempMat, c(1:60))
# Finding position of NA values
positionToEstimate = which(is.na(tempMat[, 1]))
# print(positionToEstimate)
# Removing all rows, which are just NA
M <- tempMat[rowSums(is.na(tempMat)) == 0, , drop = FALSE]
colnames(M) = c("y", "x")
# For the rows which are just NA, just make it all 0
if (all(is.na(tempMat[, 1])))
{
noDataAreas = c(noDataAreas, j)
tempMat[, 1] = rep(0, length.out = c-1)
}
else
{
# Ensuring there is enough data points to fit a spline, they are not all 0 and there are values that need to be estimated
if (nrow(M) >= 5 && sum(M[, 1] != 0) && length(positionToEstimate)>0)
{
plot(M[, 2], M[, 1])
# Fitting a b spline, with degrees of freedom 4, or the unique number of values. Adding boundary knots to limit tails
fit = lm(y ~ bs(x, df = min(length(unique(M[, 1]))), Boundary.knots = c(1, 60)), data = M)
# Fitting to draw the b spline line
predDraw = predict(fit, data.frame(x = c(1:60)))
lines(predDraw)
# predicting for the NA values
predNA = predict(fit, data.frame(x = positionToEstimate))
# print(pmin(pmax(predNA, 0), max(M[, 1])))
# print(head(tempMat))
# for the positions that need to be estimated, adding in the predicted values
# but are limiting the predicted values to be greater than 0, and less than the maximum number of cases
tempMat[positionToEstimate, 1] = pmin(pmax(predNA, 0), max(M[, 1]))
print(head(tempMat))
}
else
{
# If there are too few data points, just take the mean of them
tempMat[positionToEstimate, 1] = mean(M[, 1])
}
}
# adding in the entry, with the organisation name
filledDataFrame = rbind(filledDataFrame, c(dfMalCases$organisationunitname[j], t(tempMat[, 1])))
}
source("F:/Jembi/Gondar/DataInterpolation.R", echo=TRUE)
